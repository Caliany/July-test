/*
每日一题：
1、某主机的IP 地址为 180.80.77.55，子网掩码为 255.255.252.0。若该主机向其所在子网发送广播分组，则目 的地址可以是（180.80.79.255）；
2、ARP 协议的功能是（根据 IP 地址查询 MAC 地址 ）；
3、下列关于IP 路由器功能的描述中，正确的是：
	>运行路由协议，设置路由表；
	>监测到拥塞时，合理丢弃 IP 分组;
	>根据收到的 IP 分组的目的 IP 地址，将其转发到合适的输出线路上;
4、以太网的MAC 协议提供的是（ 无连接不可靠服务）；
5、在TCP/IP 体系结构中，直接为 ICMP 提供服务的协议是（IP ）；
6、TCP/IP 参考模型的网络层提供的是（ 无连接不可靠的数据报服务）；
7、某网络的IP地址空间为192.168.5.0/24 ， 采用定长子网划分，子网掩码为255.255.255.248，则该网络的最 大子网个数 、 每个子网内的最大可分配地址个数为(32，6)；

今年公司年会的奖品特别给力，但获奖的规矩却很奇葩： 
1. 首先，所有人员都将一张写有自己名字的字条放入抽奖箱中； 
2. 待所有字条加入完毕，每人从箱中取一个字条； 
3. 如果抽到的字条上写的就是自己的名字，那么“恭喜你，中奖了！” 
	现在告诉你参加晚会的人数，请你计算有多少概率会出现无人获奖？

错排问题：
递推公式编辑
当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推.
第一步，把第n个元素放在一个位置，比如位置k，一共有n-1种方法；
第二步，放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法；
综上得到
D(n) = (n-1) [D(n-2) + D(n-1)]
特殊地，D(1) = 0, D(2) = 1.
*/

#include <iostream>
#include <cstdio> 
using namespace std;

int main() { 
	long long d[22] = { 0, 0, 1 };       
	// 错排数量，预留第一项为0，配合下文中输入的n 
	long long f[22] = { 0, 1, 2 };    
	// 阶 乘 
	for (int i = 3; i < 22; i++) { 
		d[i] = (i - 1) * (d[i - 1] + d[i - 2]); 
		//错排的递推公式 
		f[i] = i * f[i - 1]; 
		//阶乘的递推公式 
	}
	int n; 
	while (cin >> n) {
		printf("%.2f%%\n", 100.0 * d[n] / f[n]); 
		//用100.0来把结果处理成double，保留两位小数 
	}
	return 0;
}


#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
#define M long long 

int main(){    
	M t,num[21];    
	num[1]=0;    
	num[2]=1;    
	num[3]=2;    
	for(int i=4;i<=20;i++)        
		num[i]=(i-1)*(num[i-1]+num[i-2]);    
	scanf("%Md",&t);   
	while(t--){        
		M n;
		scanf("%Md",&n);        
		M sum = 1;
		for(int i=1;i<=n;i++)            
			sum*=i;        
		printf("%.2f",num[n]*1.0/sum*100);        
		char ch='%';       
		printf("%c\n",ch);    
	}    
	return 0;
}
